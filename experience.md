# 项目经验总结

## API 集成最佳实践

### 架构设计
- 配置与业务逻辑分离，便于扩展
- API 配置统一接口格式
- 提示词模板单独管理
- 统一错误处理机制

### 认证处理
- Header 认证 (Bearer Token)
- 统一认证处理机制

## 代码规范

### 模块化设计
- 明确模块职责边界
- 避免功能重复实现
- 保持接口一致性

### 目录结构（src）
- api/: 外部 API 封装
- services/: 业务逻辑
- config/: 配置文件
- components/: UI 组件
- prompts/: 提示词模板

## LLM API 最佳实践

### OpenAI 格式标准化
- 使用 OpenAI 格式作为标准接口
- 不同模型只需配置 baseURL
- 统一使用 ChatOpenAI 类
- 减少特殊适配代码
- 最新的gemini通过baseURL为https://generativelanguage.googleapis.com/v1beta/openai对openai格式兼容

### 配置管理
- 统一的模型配置结构
  ```javascript
  {
    name: '提供商名称',
    baseURL: 'API端点', // 不包含 /chat/completions
    models: ['支持的模型列表'],
    defaultModel: '默认模型',
    enabled: false
  }
  ```

## 测试规范

### 测试组织
- 按功能模块组织测试
- 测试正常和错误情况
- 验证状态变化
- 检查边界条件

### 环境变量处理
- 不强制要求所有环境变量存在
- 缺少环境变量时优雅跳过相关测试
- 提供清晰的跳过原因

## Vue 组件开发

### Props 和 v-model
- Props 是只读的，不能直接修改
- 使用 emit 发送更新事件
- 计算属性处理双向绑定

### UI 设计
- 使用深色主题配色
- 统一的间距和圆角
- 合理的响应式布局
- 清晰的视觉层次

# 测试最佳实践

## 测试文件组织
- 对于复杂的测试套件，应该按功能模块拆分成多个测试文件
- 使用目录结构来组织不同类型的测试
- 不需要创建测试入口文件，测试运行器会自动发现和执行所有测试文件
- 每个测试文件应该只关注一个特定的功能或模块
- 将相关的测试文件放在同一目录下，便于管理和查找

## 测试文件命名
- 使用描述性的文件名，清晰表明测试的内容
- 遵循 `[feature].test.js` 的命名约定
- 对于集成测试，可以创建专门的目录如 `integration/`

## 测试代码复用
- 公共的测试设置（如环境变量加载）可以提取到共享文件中
- 每个测试文件都应该是独立的，不依赖其他测试文件的执行顺序
- 测试用例应该是独立的，不应该依赖其他测试用例的状态

# 错误处理最佳实践

## 2024-03-21 错误处理更新
- 在开发环境中，应该保留原始错误信息以便调试
- 避免过度包装错误信息，这可能会掩盖问题的真正原因
- 直接展示具体的错误信息有助于用户和开发者快速定位问题
- 错误信息应该包含足够的上下文，比如在什么操作中发生的错误

## 2024-03-21 模板 ID 与模型 key 混淆问题修复
1. 问题描述：
   - 错误地将模型的 key（如 'gemini'）作为模板 ID 传递
   - 导致系统尝试加载不存在的模板文件

2. 解决方案：
   - 明确区分模板 ID 和模型 key
   - 使用固定的 'optimize' 作为优化功能的模板 ID
   - 将模型 key 仅用于 API 调用配置

3. 最佳实践：
   - 模板 ID 应该与具体功能对应，而不是与模型对应
   - 在代码中明确区分模型标识符和模板标识符
   - 使用有意义的命名避免混淆

4. 经验总结：
   - 参数命名要清晰表达其用途
   - 配置项要按照职责划分
   - 避免在不同上下文中混用标识符
   - 保持配置的单一职责原则

## Provider 设计经验

在 LLM 服务架构中，provider 是一个核心概念，它的设计需要考虑以下几个方面：

1. **唯一标识**
   - provider 应该作为模型服务的唯一标识符
   - 用于区分不同的 AI 模型服务提供商

2. **配置完整性**
   - 每个 provider 都应该包含完整的配置信息
   - 必要字段：name、baseURL、models、defaultModel、enabled、apiKey

3. **安全性**
   - 默认模型应该受到保护，防止误删除
   - API 密钥应该与 provider 绑定管理
   - 建议使用环境变量管理敏感信息

4. **扩展性**
   - 支持自定义模型提供商的添加
   - 允许动态更新配置
   - 提供模型切换机制

5. **实例管理**
   - 使用缓存机制管理模型实例
   - 配置变更时及时清理缓存
   - 统一的实例创建和获取接口

## NPM包版本查看经验
1. 查看当前安装的直接依赖版本：
   ```bash
   npm list --depth=0
   ```
2. 查看可更新的包：
   ```bash
   npm outdated
   ```
3. 查看特定包的所有可用版本：
   ```bash
   npm view [包名] versions
   ```
4. 查看package.json中的版本号含义：
   - `^` 表示兼容补丁和小版本更新（如^1.2.3 可以更新到 1.3.0）
   - `~` 表示只兼容补丁更新（如~1.2.3 可以更新到 1.2.4）
   - `*` 表示接受所有更新

## NPM包版本更新经验
1. 使用npm-check-updates工具更新package.json：
   ```bash
   # 安装工具
   npm install -g npm-check-updates
   # 检查可更新的包
   ncu
   # 更新package.json中的版本号
   ncu -u
   # 安装新版本的包
   npm install
   ```
2. 更新注意事项：
   - 更新前先提交代码，以便出问题时回滚
   - 更新后运行测试确保功能正常
   - 如果更新后出现问题，可以使用 `git checkout package.json package-lock.json` 回滚
   - 建议逐个包更新，可以使用 `ncu -u [包名]` 更新单个包

# LLM 服务改造经验

## 2024-03-xx LangChain 替换为原生 fetch
1. 对于简单的 LLM 调用场景，使用原生 fetch 比 LangChain 更轻量和直接
2. 改造要点：
   - 保持接口稳定性，确保其他组件不需要修改
   - 统一错误处理机制
   - 保持配置的灵活性
3. 优势：
   - 减少依赖
   - 代码更直观
   - 更容易调试和维护
   - 更好的性能

# 界面优化经验总结

## 布局设计最佳实践

### 1. 响应式布局
- 使用 grid 布局实现灵活的栏目布局
- 合理使用 flex 布局处理组件内部结构
- 移动优先的设计思路
- 使用断点系统管理不同设备适配

### 2. 间距和尺寸
- 统一使用 tailwind 的间距系统
- 保持一致的内边距和外边距
- 合理使用相对单位和响应式尺寸
- 避免固定宽度，使用最小宽度和最大宽度

### 3. 组件层级
- 使用卡片式设计增强视觉层级
- 合理使用阴影和边框区分层级
- 保持组件间的视觉关系
- 统一的圆角和边框样式

## 视觉设计最佳实践

### 1. 颜色系统
- 使用 CSS 变量管理主题颜色
- 合理使用透明度创建层次感
- 确保足够的颜色对比度
- 统一的颜色命名和使用规范

### 2. 深色主题
- 避免纯黑色背景，使用深灰色
- 合理使用半透明提升层次感
- 确保文本在深色背景下的可读性
- 优化高亮和强调色的使用

### 3. 文字排版
- 清晰的字体层级系统
- 合理的行高和字间距
- 响应式的文字大小
- 统一的字体家族

## 交互设计最佳实践

### 1. 动画效果
- 适当的过渡动画增强体验
- 避免过度使用动画
- 考虑性能影响
- 提供动画禁用选项

### 2. 状态反馈
- 清晰的加载状态展示
- 明确的错误提示
- 及时的操作反馈
- 合理的禁用状态样式

### 3. 表单交互
- 直观的输入提示
- 即时的验证反馈
- 清晰的错误提示
- 优化的触摸区域

## 移动端适配最佳实践

### 1. 布局适配
- 单列布局优先
- 合理的内容重排
- 优化的触摸目标大小
- 避免横向滚动

### 2. 交互优化
- 适合触摸的按钮大小
- 清晰的点击反馈
- 避免悬停依赖
- 优化的表单体验

### 3. 性能优化
- 优化资源加载
- 减少不必要的动画
- 优化滚动性能
- 合理使用懒加载

## 通用优化原则

### 1. 一致性
- 统一的设计语言
- 一致的交互模式
- 统一的组件样式
- 一致的命名规范

### 2. 可访问性
- 足够的颜色对比度
- 合适的文字大小
- 清晰的焦点状态
- 键盘友好的交互

### 3. 性能
- 优化的资源加载
- 合理的动画使用
- 优化的渲染性能
- 减少重排和重绘

### 4. 可维护性
- 模块化的样式组织
- 清晰的命名规范
- 统一的代码风格
- 完善的文档注释

# Vue 组件测试经验总结

## 测试策略

### 1. 组件渲染测试
- 使用 `findComponent` 查找子组件，而不是直接查找DOM元素
- 检查组件的 props 而不是DOM属性，这样更稳定且不依赖于具体实现
- 对于需要检查的文本内容，优先检查组件的 props
- 确保测试覆盖所有关键子组件的存在性

### 2. 组件交互测试
- 使用 `setData` 和 `nextTick` 来模拟状态变化
- 直接检查组件的 props 变化，而不是DOM状态
- 对于表单输入，使用组件的 v-model 而不是直接操作DOM
- 确保在状态变化后等待 nextTick

### 3. 组件 Mock
- 为所有子组件提供基本的 mock 实现
- mock 中包含必要的 props 和事件
- 对于复杂的服务，提供完整的 mock API
- 确保 mock 的行为与真实组件一致

### 4. 常见问题解决
- 找不到DOM元素：检查选择器是否正确，考虑使用组件查找
- 属性未定义：确保组件正确挂载和初始化
- 异步更新问题：使用 nextTick 等待DOM更新
- 服务调用失败：提供完整的服务 mock

## 最佳实践

1. 组件测试结构
```js
describe('组件名', () => {
  let wrapper
  
  beforeEach(() => {
    // 设置测试环境
  })
  
  describe('基础渲染', () => {
    // 测试基本渲染
  })
  
  describe('交互测试', () => {
    // 测试用户交互
  })
  
  describe('响应式布局', () => {
    // 测试响应式特性
  })
})
```

2. 选择器优先级
- 组件 > class > id > tag
- 使用 data-testid 进行测试
- 避免依赖样式类名
- 优先使用语义化选择器

3. 异步处理
- 总是使用 async/await
- 在状态变化后使用 nextTick
- 处理所有异步操作的错误
- 确保测试等待所有异步操作完成

4. Mock 策略
- 只mock必要的依赖
- 保持mock简单但足够
- 验证mock的调用
- 在beforeEach中重置mock

## 注意事项

1. 避免过度测试
- 不测试实现细节
- 专注于组件契约
- 测试用户交互流程
- 避免重复测试框架功能

2. 测试维护
- 保持测试简单清晰
- 使用辅助函数减少重复
- 及时更新测试用例
- 定期检查测试覆盖率

3. 性能考虑
- 避免不必要的DOM操作
- 合理使用快照测试
- 优化测试夹具
- 适当使用测试隔离

## Vue 组件测试中的 localStorage 模拟经验

### 问题描述
在 Vue 组件测试中，如果组件依赖 localStorage，直接使用会导致测试失败，因为：
1. 测试环境中 localStorage 可能不可用
2. 测试之间可能相互影响
3. 难以追踪和验证 localStorage 的操作

### 解决方案
1. 创建完整的 localStorage 模拟：
```js
const localStorageMock = {
  store: new Map(),
  getItem: vi.fn((key) => {
    return localStorageMock.store.get(key) || null;
  }),
  setItem: vi.fn((key, value) => {
    localStorageMock.store.set(key, value);
  }),
  removeItem: vi.fn((key) => {
    localStorageMock.store.delete(key);
  }),
  clear: vi.fn(() => {
    localStorageMock.store.clear();
  })
};
```

2. 使用 Object.defineProperty 设置全局模拟：
```js
Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
  writable: true,
  configurable: true
});
```

3. 在每个测试前重置状态：
```js
beforeEach(() => {
  localStorageMock.store.clear();
  vi.clearAllMocks();
});
```

### 最佳实践
1. 使用 Map 作为底层存储，提供类似的 API
2. 使用 vi.fn() 包装所有方法以便追踪调用
3. 确保在每个测试前清理状态
4. 使用 Object.defineProperty 而不是直接赋值
5. 设置 writable 和 configurable 为 true 以允许修改

### 注意事项
1. localStorage 模拟应该在所有测试之前设置
2. 需要模拟所有常用的 localStorage 方法
3. 确保错误处理与真实 localStorage 一致
4. 考虑添加 length 和 key 方法以完全模拟
5. 注意异步操作中的 localStorage 使用

### 经验总结
1. 在测试环境中模拟浏览器 API 时，要注意属性描述符的设置
2. 使用 Map 比普通对象更适合模拟存储功能
3. 清理操作要放在 beforeEach 而不是 afterEach
4. 使用 vi.fn() 包装方法便于后续断言和验证
5. 保持模拟实现的简单性，只模拟必要的功能

# 服务类实现最佳实践

## 单例模式实现
- 如果服务类需要作为单例使用，应该在导出时就创建实例
- 不要导出类定义然后在使用时创建实例，这可能导致多个实例
- 示例：
  ```js
  export class MyService {
    // ...
  }
  export const myService = new MyService();
  ```

## 初始化逻辑
- 将必要的初始化逻辑放在构造函数中
- 如果有异步初始化需求，可以提供单独的 async init 方法
- 在构造函数中可以进行：
  - 配置加载
  - 默认值设置
  - 本地存储读取
  - 基本状态初始化

## 异步方法设计
- 明确标记哪些方法是异步的（使用 async）
- 在调用异步方法前确保方法存在
- 处理好所有可能的异步错误
- 提供清晰的错误信息

## 错误处理
- 在服务类中应该捕获并处理特定的错误
- 对外抛出统一格式的错误
- 错误信息应该清晰明确
- 在开发环境保留详细错误信息

## Vue Composables 使用经验

### Toast 组件最佳实践
1. 使用方式
   - 通过 useToast composable 获取实例
   - 使用提供的方法：success、error、info、warning
   - 不要使用 ref 或 .value 访问

2. 错误处理
   - 统一使用 toast.error 显示错误信息
   - 确保错误信息简洁明了
   - 在开发环境保留详细错误信息

3. 注意事项
   - 检查 composable 的返回值类型
   - 不要假设组件的 API 格式
   - 参考示例代码和文档

## 文件路径处理经验

### 开发环境路径
1. 使用相对路径
   - 使用 ./src 而不是 /src
   - 考虑开发服务器的根目录
   - 注意路径解析规则

2. 路径验证
   - 在加载文件前验证路径
   - 提供清晰的错误信息
   - 考虑使用路径别名

3. 生产环境考虑
   - 注意构建后的路径变化
   - 使用环境变量配置基础路径
   - 测试不同部署环境

## LLM API 调用格式规范

### 消息格式
1. LLM API 调用时，消息必须使用标准格式：
```javascript
{
  role: string,    // 消息角色，如 'user', 'system', 'assistant'
  content: string  // 消息内容
}
```

2. 发送消息时必须使用消息数组格式，即使只有一条消息：
```javascript
const messages = [
  { role: 'user', content: '用户消息' }
]
```

### 常见错误
1. ❌ 直接传入消息字符串
```javascript
await llmService.sendMessage(content)  // 错误
```

2. ✅ 正确的调用方式
```javascript
await llmService.sendMessage([
  { role: 'user', content: content }
])  // 正确
```

### 注意事项
1. LLMService 类内部已经管理模型选择，调用时不需要额外传入模型参数
2. 优化提示词和发送消息使用不同的方法和格式：
   - optimizePrompt：直接传入提示词文本和模板ID
   - sendMessage：传入标准消息数组

### 提示词测试最佳实践
1. 测试消息结构：
```javascript
const messages = [
  { role: 'system', content: optimizedPrompt || originalPrompt }, // 优化后的提示词或原始提示词
  { role: 'user', content: testContent }                         // 测试内容
]
```

2. 系统提示词选择顺序：
   - 首选：已优化的提示词（如果存在）
   - 备选：原始提示词（如果没有优化结果）

3. 测试流程：
   - 先检查是否有优化后的提示词
   - 将提示词作为系统角色消息
   - 将测试内容作为用户角色消息
   - 组合成消息数组发送给 LLM

4. 注意事项：
   - 确保系统提示词不为空
   - 优化提示词和测试内容应该配合使用
   - 保持提示词的上下文连贯性

## LLM 服务测试最佳实践

### 消息格式测试
1. 验证消息数组格式：
```javascript
expect(llmService.sendMessage).toHaveBeenCalledWith([
  { role: 'system', content: systemPrompt },
  { role: 'user', content: userContent }
])
```

2. 测试场景覆盖：
   - 使用优化后的提示词作为系统提示词
   - 使用原始提示词作为备选系统提示词
   - 错误处理和状态更新

3. 状态设置：
   - 在测试前设置必要的组件状态
   - 使用 nextTick 等待异步更新
   - 验证状态变化和服务调用

4. Mock 设置：
   - 为 LLM 服务提供合适的 mock 实现
   - 使用 mockResolvedValue 模拟成功响应
   - 使用 mockRejectedValue 模拟错误情况

5. 注意事项：
   - 确保消息格式符合 API 要求
   - 验证错误处理和状态重置
   - 测试不同提示词来源的场景
   - 确保异步操作正确处理
