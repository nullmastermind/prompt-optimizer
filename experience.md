# 项目经验总结

## API 集成最佳实践

### 架构设计
- 配置与业务逻辑分离，便于扩展
- API 配置统一接口格式
- 提示词模板单独管理
- 统一错误处理机制

### 认证处理
- Header 认证 (Bearer Token)
- 统一认证处理机制

## 代码规范

### 模块化设计
- 明确模块职责边界
- 避免功能重复实现
- 保持接口一致性

### 目录结构（src）
- api/: 外部 API 封装
- services/: 业务逻辑
- config/: 配置文件
- components/: UI 组件
- prompts/: 提示词模板

## LLM API 最佳实践

### OpenAI 格式标准化
- 使用 OpenAI 格式作为标准接口
- 不同模型只需配置 baseURL
- 统一使用 ChatOpenAI 类
- 减少特殊适配代码
- 最新的gemini通过baseURL为https://generativelanguage.googleapis.com/v1beta/openai对openai格式兼容

### 配置管理
- 统一的模型配置结构
  ```javascript
  {
    name: '提供商名称',
    baseURL: 'API端点', // 不包含 /chat/completions
    models: ['支持的模型列表'],
    defaultModel: '默认模型',
    enabled: false
  }
  ```

## 测试规范

### 测试组织
- 按功能模块组织测试
- 测试正常和错误情况
- 验证状态变化
- 检查边界条件

### 环境变量处理
- 不强制要求所有环境变量存在
- 缺少环境变量时优雅跳过相关测试
- 提供清晰的跳过原因

## Vue 组件开发

### Props 和 v-model
- Props 是只读的，不能直接修改
- 使用 emit 发送更新事件
- 计算属性处理双向绑定

### UI 设计
- 使用深色主题配色
- 统一的间距和圆角
- 合理的响应式布局
- 清晰的视觉层次

# 测试最佳实践

## 测试文件组织
- 对于复杂的测试套件，应该按功能模块拆分成多个测试文件
- 使用目录结构来组织不同类型的测试
- 不需要创建测试入口文件，测试运行器会自动发现和执行所有测试文件
- 每个测试文件应该只关注一个特定的功能或模块
- 将相关的测试文件放在同一目录下，便于管理和查找

## 测试文件命名
- 使用描述性的文件名，清晰表明测试的内容
- 遵循 `[feature].test.js` 的命名约定
- 对于集成测试，可以创建专门的目录如 `integration/`

## 测试代码复用
- 公共的测试设置（如环境变量加载）可以提取到共享文件中
- 每个测试文件都应该是独立的，不依赖其他测试文件的执行顺序
- 测试用例应该是独立的，不应该依赖其他测试用例的状态

# 错误处理最佳实践

## 2024-03-21 错误处理更新
- 在开发环境中，应该保留原始错误信息以便调试
- 避免过度包装错误信息，这可能会掩盖问题的真正原因
- 直接展示具体的错误信息有助于用户和开发者快速定位问题
- 错误信息应该包含足够的上下文，比如在什么操作中发生的错误

## Provider 设计经验

在 LLM 服务架构中，provider 是一个核心概念，它的设计需要考虑以下几个方面：

1. **唯一标识**
   - provider 应该作为模型服务的唯一标识符
   - 用于区分不同的 AI 模型服务提供商

2. **配置完整性**
   - 每个 provider 都应该包含完整的配置信息
   - 必要字段：name、baseURL、models、defaultModel、enabled、apiKey

3. **安全性**
   - 默认模型应该受到保护，防止误删除
   - API 密钥应该与 provider 绑定管理
   - 建议使用环境变量管理敏感信息

4. **扩展性**
   - 支持自定义模型提供商的添加
   - 允许动态更新配置
   - 提供模型切换机制

5. **实例管理**
   - 使用缓存机制管理模型实例
   - 配置变更时及时清理缓存
   - 统一的实例创建和获取接口

## NPM包版本查看经验
1. 查看当前安装的直接依赖版本：
   ```bash
   npm list --depth=0
   ```
2. 查看可更新的包：
   ```bash
   npm outdated
   ```
3. 查看特定包的所有可用版本：
   ```bash
   npm view [包名] versions
   ```
4. 查看package.json中的版本号含义：
   - `^` 表示兼容补丁和小版本更新（如^1.2.3 可以更新到 1.3.0）
   - `~` 表示只兼容补丁更新（如~1.2.3 可以更新到 1.2.4）
   - `*` 表示接受所有更新

## NPM包版本更新经验
1. 使用npm-check-updates工具更新package.json：
   ```bash
   # 安装工具
   npm install -g npm-check-updates
   # 检查可更新的包
   ncu
   # 更新package.json中的版本号
   ncu -u
   # 安装新版本的包
   npm install
   ```
2. 更新注意事项：
   - 更新前先提交代码，以便出问题时回滚
   - 更新后运行测试确保功能正常
   - 如果更新后出现问题，可以使用 `git checkout package.json package-lock.json` 回滚
   - 建议逐个包更新，可以使用 `ncu -u [包名]` 更新单个包

# LLM 服务改造经验

## 2024-03-xx LangChain 替换为原生 fetch
1. 对于简单的 LLM 调用场景，使用原生 fetch 比 LangChain 更轻量和直接
2. 改造要点：
   - 保持接口稳定性，确保其他组件不需要修改
   - 统一错误处理机制
   - 保持配置的灵活性
3. 优势：
   - 减少依赖
   - 代码更直观
   - 更容易调试和维护
   - 更好的性能
